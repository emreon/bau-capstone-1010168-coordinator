<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>

        <style>
            body {
                height: 100vh;
                overflow: hidden;
            }

            main {
                width: 100%;
                height: 100%;
            }

            #c {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body style="margin: 0px; padding: 0px">
        <canvas id="c"></canvas>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"
            integrity="sha512-WoO4Ih0CDOSLYafy22wZD/mcJ7k0ESLqtQsFa6zFKnEUrbtuGU+GkLtVhgt93xa2qewG5gKEC6CWlN8OaCTSVg=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        ></script>
        <script>
            const degToRad = 0.017453292519943295;
            const radToDeg = 57.29577951308232;
            const canvas = document.getElementById('c');
            // const ctx = canvas.getContext('2d');

            const Y = 100;
            const workspace = { x: 420, y: 420 };
            const armWidth = 10;
            const options = { yOffset: 0 };
            const arm = { len: 345, angleDeg: 0, next: { len: 350, angleDeg: 0 } };
            let target = { x: 0, y: 0 };
            let mouse = { x: 0, y: 0 };

            function render() {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();

                let { yOffset } = options;
                let { x, y } = target;
                x = Math.max(x, 0);
                y = Math.max(y, yOffset);

                const L1 = arm.len;
                const L2 = arm.next.len;

                // const angle2 = Math.acos((x * x + y * y + L1 + L2) / (2 * L1 * L2));
                // const angle1 = Math.atan(x / y) - Math.atan((L2 * Math.sin(angle2)) / (L1 + L2 * Math.cos(angle2)));

                // console.log('target:', target, 'a1:', parseInt(angle1 * radToDeg), 'a2:', parseInt(angle2 * radToDeg));
                // if (!isNaN(angle1) && !isNaN(angle2)) {
                //     arm.angleDeg = angle1 * radToDeg;
                //     arm.next.angleDeg = angle2 * radToDeg;
                // }

                let a = Math.atan(y / x);
                // let q2 = Math.acos((x * x + y * y - L1 * L1 - L2 * L2) / (2 * L1 * L2));
                let q2 = -Math.acos((x * x + y * y - L1 * L1 - L2 * L2) / (2 * L1 * L2));
                let q1 = Math.atan(y / x) - Math.atan((L2 * Math.sin(q2)) / (L1 + L2 * Math.cos(q2)));

                // console.log('target:', target, 'q1:', parseInt(q1 * radToDeg), 'q2:', parseInt(q2 * radToDeg));
                if (!isNaN(q1) && !isNaN(q2)) {
                    arm.angleDeg = q1 * radToDeg;
                    arm.next.angleDeg = q2 * radToDeg;
                } else {
                    arm.angleDeg = a * radToDeg;
                    arm.next.angleDeg = 0;
                }

                // https://stackoverflow.com/questions/8326191/html5-canvas-subscript-and-superscript
                let textY = 10;
                let textYInc = 30;
                ctx.font = '22px monospace';
                ctx.fillText(` α: ${String(parseInt(a * radToDeg)).padStart(4, ' ')}°`, 20, (textY += textYInc));
                ctx.fillText(`${parseInt(x)}px ${parseInt(y)}px`, mouse.x, mouse.y - 20);
                ctx.fillText(`θ₁: ${String(parseInt(q1 * radToDeg)).padStart(4, ' ')}°`, 20, (textY += textYInc));
                ctx.fillText(`θ₂: ${String(parseInt(q2 * radToDeg)).padStart(4, ' ')}°`, 20, (textY += textYInc));
                ctx.fillText(
                    `θ₃: ${String(parseInt((q1 + q2) * radToDeg)).padStart(4, ' ')}°`,
                    20,
                    (textY += textYInc)
                );

                textY += textYInc;
                ctx.fillText(`L₁: ${parseInt(arm.len)}px`, 20, (textY += textYInc));
                ctx.fillText(`L₂: ${parseInt(arm.next.len)}px`, 20, (textY += textYInc));

                ctx.translate(canvas.width / 2, canvas.height - Y);
                ctx.strokeStyle = 'blue';
                ctx.strokeRect(0, -yOffset, workspace.x, -workspace.y);

                ctx.strokeStyle = 'green';
                ctx.beginPath();
                ctx.moveTo(-canvas.width / 2, -yOffset);
                ctx.lineTo(canvas.width / 2, -yOffset);
                ctx.stroke();

                ctx.rotate(-arm.angleDeg * degToRad);
                ctx.fillStyle = 'black';
                ctx.fillRect(0, -armWidth / 2, arm.len, armWidth);
                ctx.beginPath();
                ctx.arc(0, 0, armWidth * 2, 0, 2 * Math.PI);
                ctx.fill();

                ctx.translate(arm.len, 0);
                ctx.rotate(-arm.next.angleDeg * degToRad);
                ctx.fillStyle = 'red';
                ctx.fillRect(0, -armWidth / 2, arm.next.len, armWidth);
                ctx.beginPath();
                ctx.arc(0, 0, armWidth / 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(arm.next.len, 0, armWidth / 2, 0, 2 * Math.PI);
                ctx.fill();

                ctx.restore();
                window.requestAnimationFrame(render);
                // setTimeout(() => window.requestAnimationFrame(render), 1000);
            }
            window.requestAnimationFrame(render);

            window.addEventListener('mousemove', (e) => {
                mouse = { x: e.clientX, y: e.clientY };
                target = { x: e.clientX - canvas.width / 2, y: -(e.clientY - canvas.height + Y) };
            });

            window.addEventListener('resize', () => {
                canvas.width = document.body.clientWidth;
                canvas.height = document.body.clientHeight;
            });
            canvas.width = document.body.clientWidth;
            canvas.height = document.body.clientHeight;

            // dat.gui
            const gui = new dat.GUI({ name: 'My GUI' });
            gui.add(arm, 'len', 50, 400).name('L1');
            gui.add(arm.next, 'len', 50, 400).name('L2');
            gui.add(options, 'yOffset', 0, 200).name('Y Offset');
            gui.add(
                {
                    // https://stackoverflow.com/questions/18366229/is-it-possible-to-create-a-button-using-dat-gui
                    reset: () => {
                        arm.len = 180;
                        arm.next.len = 180;
                        options.yOffset = 30;

                        // https://stackoverflow.com/questions/16166440/refresh-dat-gui-with-new-values
                        for (var i in gui.__controllers) {
                            gui.__controllers[i].updateDisplay();
                        }
                    },
                },
                'reset'
            ).name('Reset');
        </script>
    </body>
</html>
